// Copyright 2024 RISC Zero, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

use alloy_primitives::{FixedBytes, Sealable, U256, utils::parse_units};
use alloy_sol_types::SolValue;
use risc0_steel::{
    config::ETH_MAINNET_CHAIN_SPEC,
    ethereum::{EthBlockHeader, EthViewCallInput},
    BlockCommitment, ViewCall,
};
use risc0_zkvm::guest::env::{self};
use std::collections::HashMap;
use tokemak::{calculate_dex_stats, DexStatsInput, cbETHInterface, CBETH_ADDRESS, LstDexStats};

// TODO remove inline block, just used for profiling
#[inline(never)]
fn hash_headers_upwards(
    headers: Vec<EthBlockHeader>,
) -> (FixedBytes<32>, u64, HashMap<FixedBytes<32>, (u64, u64)>) {
    let mut current_hash: FixedBytes<32> = headers[0].hash_slow();
    let mut current_height: u64 = headers[0].number;
    let mut validated_hashes: HashMap<FixedBytes<32>, (u64, u64)> = HashMap::new();

    validated_hashes.insert(current_hash, (headers[0].timestamp, current_height));

    for header in &headers[1..] {
        assert_eq!(current_hash, header.parent_hash);
        current_hash = header.hash_slow();
        current_height = header.number;

        validated_hashes.insert(current_hash, (header.timestamp, current_height));
    }

    (current_hash, current_height, validated_hashes)
}

fn main() {
    // TODO: ensure that we're getting blocks stepping back from the end block, not from the start block
    // we want our last value to correspond to the end_commitment

    // Read the input from the guest environment.
    let (inputs, block_headers): (Vec<EthViewCallInput>, Vec<EthBlockHeader>) = env::read();

    // Prove the hash link from the block queried upwards.
    let (block_hash, block_num, validated_hashes) = hash_headers_upwards(block_headers);
    let end_commitment =
        BlockCommitment { blockHash: block_hash, blockNumber: U256::from(block_num) };

    let mut dex_inputs = Vec::<DexStatsInput>::new();
    for input in inputs {
        let mut view_call_env = input.into_env().with_chain_spec(&ETH_MAINNET_CHAIN_SPEC);
        let commitment = view_call_env.block_commitment();

        // confirm that the hash is in the validated set and get the associated timestamp
        let (timestamp, block_number) = validated_hashes.get(&commitment.blockHash).unwrap();

        // Execute the view call; it returns the result in the type generated by the `sol!` macro.
        let backing = view_call_env
            .execute(ViewCall::new(cbETHInterface::exchangeRateCall {}, CBETH_ADDRESS))
            ._0;

        dex_inputs.push(DexStatsInput {
            timestamp: *timestamp,
            block_number: *block_number,
            lst_backing: backing,
        });
    }

    let res = calculate_dex_stats(&dex_inputs, 1);
    let base_yield: U256 = parse_units(&res.base_yield.to_string(), "ether").unwrap().into();
    let output = LstDexStats {
        commitment: end_commitment,
        baseYield: base_yield,
    };

    env::commit_slice(&output.abi_encode());
}